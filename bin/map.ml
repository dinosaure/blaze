let const x _ = x
let emitter_of_queue q = function Some str -> Queue.push str q | None -> ()
let error_msgf fmt = Fmt.kstr (fun msg -> Error (`Msg msg)) fmt
let ( let@ ) finally fn = Fun.protect ~finally fn

let stream_of_queue q () =
  match Queue.pop q with
  | v -> Some (v, 0, String.length v)
  | exception Queue.Empty -> None

let blit src src_off dst dst_off len =
  Bstr.blit_from_string src ~src_off dst ~dst_off ~len

let empty_part ~header = Mrmime.Mt.part ~header (const None)

let lines ic =
  let init () = ic
  and stop = Fun.const ()
  and pull ic =
    match input_line ic with
    | line -> Some (line ^ "\r\n", ic)
    | exception End_of_file -> None in
  Flux.Source { init; stop; pull }

let parser ic =
  let uid = ref (-1) in
  let tbl = Hashtbl.create 0x10 in
  let emitters _header =
    incr uid ;
    let v = !uid in
    let contents = Queue.create () in
    Hashtbl.add tbl v contents ;
    (emitter_of_queue contents, v) in
  let parser = Mrmime.Mail.stream emitters in
  let parser = Flux_angstrom.parser parser in
  let src = lines ic in
  let stream = Flux.Stream.from src in
  match Flux.Stream.into parser stream with
  | Ok (header, mail) -> Ok (header, mail, tbl)
  | Error _ -> error_msgf "Invalid incoming email"

let encoder header mail tbl =
  let open Mrmime in
  let rec to_mail = function
    | header, Mail.Leaf body ->
        let body = stream_of_queue (Hashtbl.find tbl body) in
        Mt.part ~header body |> Mt.make Header.empty Mt.simple
    | header, Mail.Message (header', body) ->
        to_mail (header', body)
        |> Mt.to_stream
        |> Mt.part ~header
        |> Mt.make Header.empty Mt.simple
    | header, Mail.Multipart parts ->
        let f (header, body) =
          match body with
          | Some body -> to_part (header, body)
          | None -> empty_part ~header in
        let parts = List.map f parts in
        Mt.multipart ~header ~rng:Mt.rng parts |> Mt.make Header.empty Mt.multi
  and to_part = function
    | header, Mail.Leaf body ->
        let body = stream_of_queue (Hashtbl.find tbl body) in
        Mt.part ~header body
    | header, Mail.Message (header', body) ->
        to_mail (header', body) |> Mt.to_stream |> Mt.part ~header
    | header, Mail.Multipart parts ->
        let f (header, body) =
          match body with
          | Some body -> to_part (header, body)
          | None -> empty_part ~header in
        let parts = List.map f parts in
        Mt.multipart ~header ~rng:Mt.rng parts |> Mt.multipart_as_part in
  to_mail (header, mail)

let crlf = Astring.String.Sub.v "\r\n"

(* XXX(dinosaure): it's needed to sanitize the incoming stream because we composed
   it with unsanitized streams. So we have a mix between "line per line" streams
   generated by [mrmime] and non "line per line" streams. *)

let rec transmit state oc stream =
  match stream () with
  | Some (_, _, 0) -> transmit state oc stream
  | Some (str, off, len) when state = `CR && str.[0] = '\n' -> begin
      output_char oc '\n' ;
      let open Astring.String in
      let lines =
        List.map Sub.to_string
          (Sub.cuts ~sep:crlf (sub_with_range ~first:(off + 1) ~len str)) in
      let lines = String.concat "\n" lines in
      match str.[off + len - 1] with
      | '\r' ->
          output_substring oc lines 0 (String.length lines - 1) ;
          transmit `CR oc stream
      | _ ->
          output_string oc lines ;
          transmit `None oc stream
    end
  | Some (str, off, len) -> begin
      let open Astring.String in
      let lines =
        List.map Sub.to_string
          (Sub.cuts ~sep:crlf (sub_with_range ~first:off ~len str)) in
      let lines = String.concat "\n" lines in
      match str.[off + len - 1] with
      | '\r' ->
          output_substring oc lines 0 (String.length lines - 1) ;
          transmit `CR oc stream
      | _ ->
          output_string oc lines ;
          transmit `None oc stream
    end
  | None -> ()

let run _ diff input output =
  let ic, close_ic =
    match input with
    | Some filepath -> (open_in_bin filepath, close_in)
    | None -> (stdin, ignore) in
  let@ () = fun () -> close_ic ic in
  let v = parser ic in
  match (v, diff) with
  | Ok (header, mail, tbl), false ->
      let mail' = encoder header mail tbl in
      let output = Option.map Fpath.to_string output in
      let oc, close_oc =
        match output with
        | Some filepath -> (open_out_bin filepath, close_out)
        | None -> (stdout, ignore) in
      transmit `None oc (Mrmime.Mt.to_stream mail') ;
      close_oc oc ;
      `Ok ()
  | Ok _, _ -> assert false
  | Error (`Msg err), _ -> `Error (false, Fmt.str "%s." err)

open Cmdliner
open Blaze_cli

let existing_file =
  let parser = function
    | "-" -> Ok None
    | str when Sys.file_exists str && Sys.is_regular_file str -> Ok (Some str)
    | str -> error_msgf "%S is not an existing and/or regular file" str in
  let pp = Fmt.option ~none:(Fmt.any "-") Fmt.string in
  Arg.conv (parser, pp)

let input =
  let doc = "The email to decode & encode." in
  Arg.(value & pos 0 existing_file None & info [] ~doc)

let new_file = Arg.conv (Fpath.of_string, Fpath.pp)

let output =
  let doc = "The path of the encoded email." in
  Arg.(value & opt (some new_file) None & info [ "o"; "output" ] ~doc)

let diff =
  let doc =
    "Instead to show the encoded email, we show the diff from the source." in
  Arg.(value & flag & info [ "diff" ] ~doc)

let cmd =
  let doc = "Try to decode and encode the given message." in
  let man =
    [
      `S Manpage.s_description;
      `P "From the given email, we try to decode and encode it.";
    ] in
  let term =
    let open Term in
    ret (const run $ setup_logs $ diff $ input $ output) in
  let info = Cmd.info "map" ~doc ~man in
  Cmd.v info term
