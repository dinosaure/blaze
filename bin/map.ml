open Rresult

let const x _ = x
let ( <.> ) f g x = f (g x)
let emitter_of_queue q = function Some str -> Queue.push str q | None -> ()

let stream_of_queue q () =
  match Queue.pop q with
  | v -> Some (v, 0, String.length v)
  | exception Queue.Empty -> None

let blit src src_off dst dst_off len =
  Bigstringaf.blit_from_string src ~src_off dst ~dst_off ~len

let empty_part ~header = Mrmime.Mt.part ~header (const None)

let parser ic =
  let uid = ref (-1) in
  let tbl = Hashtbl.create 0x10 in
  let emitters _header =
    incr uid ;
    let v = !uid in
    let contents = Queue.create () in
    Hashtbl.add tbl v contents ;
    (emitter_of_queue contents, v) in
  let parser = Mrmime.Mail.stream emitters in
  let rec loop ic ke = function
    | Angstrom.Unbuffered.Done (_, (header, mail)) -> R.ok (header, mail, tbl)
    | Fail _ -> R.error_msgf "Invalid incoming email"
    | Partial { committed; continue } -> (
        Ke.Rke.N.shift_exn ke committed ;
        if committed = 0 then Ke.Rke.compress ke ;
        match input_line ic with
        | line ->
            Ke.Rke.N.push ke ~blit ~length:String.length ~off:0
              ~len:(String.length line) line ;
            Ke.Rke.push ke '\r' ;
            Ke.Rke.push ke '\n' ;
            let[@warning "-8"] (slice :: _) = Ke.Rke.N.peek ke in
            loop ic ke
              (continue slice ~off:0 ~len:(Bigstringaf.length slice) Incomplete)
        | exception End_of_file ->
            let buf =
              match Ke.Rke.length ke with
              | 0 -> Bigstringaf.empty
              | _ ->
                  Ke.Rke.compress ke ;
                  List.hd (Ke.Rke.N.peek ke) in
            loop ic ke
              (continue buf ~off:0 ~len:(Bigstringaf.length buf) Complete))
  in
  let ke = Ke.Rke.create ~capacity:0x1000 Bigarray.char in
  loop ic ke (Angstrom.Unbuffered.parse parser)

let encoder header mail tbl =
  let open Mrmime in
  let rec to_mail = function
    | header, Mail.Leaf body ->
        let body = stream_of_queue (Hashtbl.find tbl body) in
        Mt.part ~header body |> Mt.make Header.empty Mt.simple
    | header, Mail.Message (header', body) ->
        to_mail (header', body)
        |> Mt.to_stream
        |> Mt.part ~header
        |> Mt.make Header.empty Mt.simple
    | header, Mail.Multipart parts ->
        let f (header, body) =
          match body with
          | Some body -> to_part (header, body)
          | None -> empty_part ~header in
        let parts = List.map f parts in
        Mt.multipart ~header ~rng:Mt.rng parts |> Mt.make Header.empty Mt.multi
  and to_part = function
    | header, Mail.Leaf body ->
        let body = stream_of_queue (Hashtbl.find tbl body) in
        Mt.part ~header body
    | header, Mail.Message (header', body) ->
        to_mail (header', body) |> Mt.to_stream |> Mt.part ~header
    | header, Mail.Multipart parts ->
        let f (header, body) =
          match body with
          | Some body -> to_part (header, body)
          | None -> empty_part ~header in
        let parts = List.map f parts in
        Mt.multipart ~header ~rng:Mt.rng parts |> Mt.multipart_as_part in
  to_mail (header, mail)

let crlf = Astring.String.Sub.v "\r\n"

(* XXX(dinosaure): it's needed to sanitize the incoming stream because we composed
   it with unsanitized streams. So we have a mix between "line per line" streams
   generated by [mrmime] and non "line per line" streams. *)

let rec transmit state oc stream =
  match stream () with
  | Some (_, _, 0) -> transmit state oc stream
  | Some (str, off, len) when state = `CR && str.[0] = '\n' -> (
      output_char oc '\n' ;
      let lines =
        List.map Astring.String.Sub.to_string
          Astring.String.(
            Sub.cuts ~sep:crlf (sub_with_range ~first:(off + 1) ~len str)) in
      let lines = String.concat "\n" lines in
      match str.[off + len - 1] with
      | '\r' ->
          output_substring oc lines 0 (String.length lines - 1) ;
          transmit `CR oc stream
      | _ ->
          output_string oc lines ;
          transmit `None oc stream)
  | Some (str, off, len) -> (
      let lines =
        List.map Astring.String.Sub.to_string
          Astring.String.(
            Sub.cuts ~sep:crlf (sub_with_range ~first:off ~len str)) in
      let lines = String.concat "\n" lines in
      match str.[off + len - 1] with
      | '\r' ->
          output_substring oc lines 0 (String.length lines - 1) ;
          transmit `CR oc stream
      | _ ->
          output_string oc lines ;
          transmit `None oc stream)
  | None -> ()

let map _ diff input output =
  let ic, close_ic =
    match input with
    | Some fpath -> (open_in (Fpath.to_string fpath), close_in)
    | None -> (stdin, ignore) in
  let v = parser ic in
  close_ic ic ;
  match (v, diff) with
  | Ok (header, mail, tbl), false ->
      let mail' = encoder header mail tbl in
      let oc, close_oc =
        match output with
        | Some fpath -> (open_out (Fpath.to_string fpath), close_out)
        | None -> (stdout, ignore) in
      transmit `None oc (Mrmime.Mt.to_stream mail') ;
      close_oc oc ;
      `Ok 0
  | Ok _, _ -> assert false
  | Error (`Msg err), _ -> `Error (false, Fmt.str "%s." err)

open Cmdliner
open Args

let existing_file =
  let parser = function
    | "-" -> Ok None
    | str ->
    match Fpath.of_string str with
    | Ok v when Sys.file_exists str -> Ok (Some v)
    | Ok v -> Rresult.R.error_msgf "%a not found" Fpath.pp v
    | Error _ as err -> err in
  Arg.conv (parser, Fmt.option ~none:(Fmt.any "-") Fpath.pp)

let input =
  let doc = "The email to decode & encode." in
  Arg.(value & pos 0 existing_file None & info [] ~doc)

let new_file = Arg.conv (Fpath.of_string, Fpath.pp)

let output =
  let doc = "The path of the encoded email." in
  Arg.(value & opt (some new_file) None & info [ "o"; "output" ] ~doc)

let diff =
  let doc =
    "Instead to show the encoded email, we show the diff from the source." in
  Arg.(value & flag & info [ "diff" ] ~doc)

let map =
  let doc = "Try to decode and encode the given message." in
  let man =
    [
      `S Manpage.s_description;
      `P "From the given email, we try to decode and encode it.";
    ] in
  ( Term.(ret (const map $ setup_logs $ diff $ input $ output)),
    Term.info "map" ~doc ~man )

let () = Term.(exit_status @@ eval map)
